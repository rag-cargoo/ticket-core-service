# 동시성 제어 전략 (Concurrency Control Strategy)

> **Purpose**: 선착순 좌석 예약 시스템에서 발생하는 데이터 정합성 문제 해결 및 성능 최적화 전략 기록
> **Date**: 2026-02-05

## 0. 이론 배경: 낙관적 락 vs 비관적 락 (Theory)

| 특징 | 낙관적 락 (Optimistic Lock) | 비관적 락 (Pessimistic Lock) |
| :--- | :--- | :--- |
| **기본 사상** | "충돌은 드물 거야. 충돌 나면 그때 해결하자." | "충돌은 빈번할 거야. 아예 못 건드리게 막자." |
| **구현 방식** | DB 락을 걸지 않음. 버전 컬럼(`@Version`) 비교. | DB 락(`SELECT ... FOR UPDATE`)을 실제로 검. |
| **성능 (DB)** | **높음** (락 대기 없음) | **낮음** (대기 발생, 데드락 위험) |
| **충돌 처리** | 예외 발생 (`Exception`) -> 롤백 -> 재시도 필요 | 대기 (`Wait`) -> 순차 처리 -> 성공 |
| **적합한 상황** | **읽기가 많고 충돌이 적은 경우** | **쓰기가 많고 충돌이 잦은 경우** |
| **대표 예시** | **게시판 수정, 프로필 업데이트** | **선착순 예매, 재고 차감, 계좌 이체** |

---

## 실험 기록 순서 (Progress)
1. [Step 0: 문제 상황 (락 미적용)](#step-0-문제-상황-락-미적용) - **Completed**
2. [Step 1: 낙관적 락 (Optimistic Lock)](#step-1-낙관적-락-optimistic-lock) - **Completed**
3. [Step 2: 비관적 락 (Pessimistic Lock)](#step-2-비관적-락-pessimistic-lock) - **Completed**
4. [Step 3: Redis 분산 락 (Distributed Lock)](#) - Pending

---

## Step 0: 문제 상황 (락 미적용)
*   **결과**: 30명 중 10명이 중복 예약 성공 (데이터 정합성 깨짐).
*   **원인**: Race Condition 발생.

## Step 1: 낙관적 락 (Optimistic Lock)
*   **결과**: 1명 성공, 29명 `OptimisticLockException` 발생.
*   **특징**: DB 락 없이 버전(`@Version`) 관리로 충돌 감지.
*   **한계**: 충돌 시 사용자에게 에러를 반환하므로 UX가 좋지 않음 (재시도 필요).

---

## Step 2: 비관적 락 (Pessimistic Lock)

### 1. 목적 (Objective)
DB의 `SELECT ... FOR UPDATE` (배타 락)을 사용하여 동시 요청을 **대기(Wait)** 상태로 만들고, 순차적으로 처리하여 데이터 정합성을 보장한다.

### 2. 실험 시나리오
- **테스트 코드**: `동시성_테스트_2_비관적_락.java`
- **쿼리**: `@Lock(LockModeType.PESSIMISTIC_WRITE)`
- **대상**: 1개 좌석 (Seat ID: 1)
- **부하**: 30명의 스레드가 동시에 예약 API 호출

### 3. 실험 결과 및 로그 분석

#### [수치 결과]
| 항목 | 결과값 |
| :--- | :--- |
| **성공 횟수** | 1건 |
| **실패 횟수** | 29건 |
| **최종 예약 건수** | 1건 (정합성 유지 완료) |

#### [실제 SQL 로그 증거]
모든 스레드가 `for update`를 통해 락을 획득하려고 시도함.

```sql
/* SELECT s FROM Seat s WHERE s.id = :id */ 
select
    s1_0.id, ...
from
    seats s1_0 
where
    s1_0.id=? for update
```

#### [동작 방식]
1.  Thread A가 락을 획득하고 예약을 진행함.
2.  Thread B, C...는 DB 레벨에서 대기(Blocking)함.
3.  Thread A가 커밋하고 락을 반납함.
4.  Thread B가 락을 획득하고 진입했으나, 이미 좌석 상태가 `RESERVED`임을 확인하고 예외 발생 (`Seat is already reserved`).

### 4. 결론 (Conclusion)
*   **정합성**: 완벽함.
*   **장점**: 낙관적 락과 달리 **순차 처리**가 보장됨. 데이터가 절대 꼬이지 않음.
*   **단점**: 모든 요청이 줄을 서야 하므로 **DB 커넥션 점유 시간이 길어짐**. 트래픽이 폭주하면 DB 전체가 느려질 수 있음.
*   **의사 결정**: 단일 DB 환경에서는 가장 확실한 방법이나, **대규모 트래픽** 환경에서는 DB 부하를 줄이기 위해 **Redis 분산 락** 도입을 고려해야 함.

---
> **Next Step**: DB 락을 사용하지 않고 Redis를 이용해 락을 관리하는 **분산 락(Distributed Lock)** 실험 진행 예정.