# 동시성 제어 전략 (Concurrency Control Strategy)

> **Purpose**: 선착순 좌석 예약 시스템에서 발생하는 데이터 정합성 문제 해결 및 성능 최적화 전략 기록
> **Date**: 2026-02-05

## 0. 이론 배경: 낙관적 락 vs 비관적 락 (Theory)

| 특징 | 낙관적 락 (Optimistic Lock) | 비관적 락 (Pessimistic Lock) |
| :--- | :--- | :--- |
| **기본 사상** | "충돌은 드물 거야. 충돌 나면 그때 해결하자." | "충돌은 빈번할 거야. 아예 못 건드리게 막자." |
| **구현 방식** | **애플리케이션 로직**: 버전 컬럼(`@Version`) 비교. | **DB 쿼리**: `SELECT ... FOR UPDATE`로 물리적 락. |
| **성능 (DB)** | **높음** (락 대기 없음) | **낮음** (대기 발생, 데드락 위험) |
| **충돌 처리** | 예외 발생 (`Exception`) -> 롤백 -> 재시도 필요 | 대기 (`Wait`) -> 순차 처리 -> 성공 |
| **대표 예시** | 게시판 수정, 프로필 업데이트 | 선착순 예매, 재고 차감, 계좌 이체 |

---

## 📋 실험 기록 순서 (Progress)
1. [Step 0: 문제 상황 (락 미적용)](#step-0-문제-상황-락-미적용) - **Completed**
2. [Step 1: 낙관적 락 (Optimistic Lock)](#step-1-낙관적-락-optimistic-lock) - **Completed**
3. [Step 2: 비관적 락 (Pessimistic Lock)](#step-2-비관적-락-pessimistic-lock) - **Completed**
4. [Step 3: Redis 분산 락 (Distributed Lock)](#step-3-redis-분산-락-distributed-lock) - **Completed**
5. [Step 4: Kafka 기반 비동기 대기열 (Async Queue)](#step-4-kafka-기반-비동기-대기열-async-queue) - **Completed**
6. [Step 5: Redis Sorted Set 기반 실시간 대기열](#step-5-redis-sorted-set-기반-실시간-대기열) - **Completed**
7. [Step 6: 유입량 제어 전략 (Throttling)](#step-6-유입량-제어-전략-throttling) - **In Progress**

---

## Step 0: 문제 상황 (락 미적용)

### 1. 실험 시나리오 (Experimental Scenario)
- **테스트 코드**: `동시성_테스트_1_낙관적_락.java` (JPA @Version 주석 처리 후 실행)
- **대상**: 1개 좌석 (Seat ID: 1)
- **부하**: 30명의 스레드가 동시에 예약 API 호출

### 2. 잘못된 구현 방식 (The Wrong Way)
아무런 보호 장치 없이 일반적인 조회와 수정을 반복하는 방식입니다.
```java
@Transactional
public void reserve(Long seatId) {
    Seat seat = seatRepository.findById(seatId).orElseThrow();
    seat.reserve();
}
```

### 3. 실험 결과 (실패)
데이터 정합성이 완전히 깨지는 현상이 발생함. (중복 예약 발생)

---

## Step 1: 낙관적 락 (Optimistic Lock)

### 1. 구현 방법
엔티티에 `@Version` 컬럼을 추가하여 JPA 레벨에서 버전 체크를 수행합니다.
```java
@Version 
private Long version;
```

### 2. 실험 결과 및 분석
*   **성공 횟수**: 1건
*   **결론**: 정합성은 보장하나, 충돌 시 예외가 발생하므로 대규모 선착순에는 사용자 경험이 좋지 않음.

---

## Step 2: 비관적 락 (Pessimistic Lock)

### 1. 구현 방법
`SELECT ... FOR UPDATE` 쿼리를 사용하여 DB 수준에서 락을 겁니다.
```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT s FROM Seat s WHERE s.id = :id")
Optional<Seat> findByIdWithPessimisticLock(@Param("id") Long id);
```

### 2. 결론
강력한 정합성을 보장하지만, 대기 시간이 길어질 경우 DB 커넥션 고갈 위험이 있음.

---

## 🚨 락(Lock)만으로는 해결할 수 없는 현실적인 문제
- **UX 파괴**: 만 명 중 한 명만 성공하고 나머지는 즉시 실패.
- **서버 마비**: DB 커넥션 풀이 락 대기로 인해 마비됨.

---

## Step 3: Redis 분산 락 (Distributed Lock)

### 1. Facade 패턴 도입 배경
락의 해제 시점이 트랜잭션 커밋 시점보다 늦어야 정합성이 유지되므로, 별도의 Facade 클래스에서 락을 관리합니다.

### 2. 🌟 Magic Number를 배제한 자율적 설계
- **짐작하는 숫자 배제**: `leaseTime`을 `-1`로 설정하여 Redisson Watchdog이 자율적으로 락 시간을 연장하게 함.
- **핵심 교훈**: "상황을 단정 짓지 말고, 시스템이 흐르게 하라."

---

## Step 4: Kafka 기반 비동기 대기열 (Async Queue) ✅

### 1. 왜 '대기열' 방식인가? (The Paradigm Shift)
"한 놈만 들어와"에서 "모두 줄을 서세요"로 패러다임을 전환하여 서버 부하를 분산합니다.

### 2. 구현 매커니즘
- **Producer**: 요청을 Kafka에 적재 (Key: `seatId`).
- **Consumer**: 감당 가능한 속도로 메시지를 소비하여 처리.
- **Notification**: SSE를 이용한 실시간 결과 통보.

---

## Step 5: Redis Sorted Set 기반 실시간 대기열 ✅

### 1. 개요 (Overview)
사용자에게 "내 앞에 몇 명이 남았는지" 시각적 피드백을 제공합니다.

### 2. 핵심 매커니즘: Redis Sorted Set (ZSET)
- **Key**: `waiting-queue:concert:{concertId}`
- **Member**: `userId`
- **Score**: `System.currentTimeMillis()` (도착 시간 기반 자동 정렬)

### 3. Redis Z-명령어 상세 및 Java 구현

| 명령어 | 설명 | Java 활용 예시 |
| :--- | :--- | :--- |
| **ZADD** | 대기열 진입 | `opsForZSet().add(key, userId, score)` |
| **ZRANK** | 내 순위 조회 (0-based) | `opsForZSet().rank(key, userId)` |
| **ZRANGE** | 활성화 대상 추출 | `opsForZSet().range(key, start, stop)` |
| **ZREM** | 대기열에서 제거 | `opsForZSet().remove(key, userId)` |
| **ZCARD** | 현재 대기자 수 | `opsForZSet().size(key)` |

---

## Step 6: 유입량 제어 전략 (Throttling) 👈 (Next)

### 1. 개요 (Overview)
서버가 감당 가능한 만큼만 들여보내는 유입량 제어 로직을 적용합니다.

### 2. 핵심 제어 매커니즘
1.  **진입 차단 (Throttling)**: `ZCARD`로 현재 대기열 크기를 확인하여 임계치(예: 50,000명) 초과 시 진입 거부.
2.  **유입량 동적 조절 (Dynamic Batching)**: 서버 상태에 따라 활성화 인원수를 유동적으로 조절.
3.  **ACTIVE 토큰 검증 (Security)**: `ActiveUserInterceptor`를 구현하여 대기열 우회 접속 차단.

### 3. 구현 상태 (Status)
- [x] `WaitingQueueService` 내 `ZCARD` 기반 진입 제한 로직 추가.
- [ ] `ActiveUserInterceptor` 및 `WebMvcConfigurer` 등록.