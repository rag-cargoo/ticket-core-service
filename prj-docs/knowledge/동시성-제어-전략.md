# 동시성 제어 및 고성능 대기열 전략 (Concurrency & Queue Strategy)

> **Purpose**: 선착순 좌석 예약 시스템의 정합성 문제 해결부터 초고속 대기열 설계까지의 기술적 여정 기록
> **Date**: 2026-02-07

---

## 📂 목차 (Table of Contents)

*   💡 [이론 배경: 낙관적 락 vs 비관적 락](#-이론-배경-낙관적-락-vs-비관적-락-theory)
*   🚀 [Step 0: 문제 상황 (락 미적용)](#-step-0-문제-상황-락-미적용)
*   🚀 [Step 1: 낙관적 락 (Optimistic Lock)](#-step-1-낙관적-락-optimistic-lock)
*   🚀 [Step 2: 비관적 락 (Pessimistic Lock)](#-step-2-비관적-락-pessimistic-lock)
*   ⚠️ [락(Lock)의 한계와 현실적인 문제](#-락lock의-한계와-현실적인-문제)
*   🚀 [Step 3: Redis 분산 락 (Distributed Lock)](#-step-3-redis-분산-락-distributed-lock)
    *   [Magic Number 배제 및 자율적 설계](#-magic-number를-배제한-자율적-시스템-설계-중요)
*   🚀 [Step 4: Kafka 기반 비동기 대기열 (Async Queue)](#-step-4-kafka-기반-비동기-대기열-async-queue)
*   🚀 [Step 5: Redis Sorted Set 기반 실시간 대기열](#-step-5-redis-sorted-set-기반-실시간-대기열)
*   🚀 [Step 6: 유입량 제어 전략 (Throttling)](#-step-6-유입량-제어-전략-throttling)

---

## 💡 이론 배경: 낙관적 락 vs 비관적 락 (Theory)

| 특징 | 낙관적 락 (Optimistic Lock) | 비관적 락 (Pessimistic Lock) |
| :--- | :--- | :--- |
| **기본 사상** | "충돌은 드물 거야. 충돌 나면 그때 해결하자." | "충돌은 빈번할 거야. 아예 못 건드리게 막자." |
| **구현 방식** | **애플리케이션 로직**: 버전 컬럼(`@Version`) 비교. | **DB 쿼리**: `SELECT ... FOR UPDATE`로 물리적 락. |
| **성능 (DB)** | **높음** (락 대기 없음) | **낮음** (대기 발생, 데드락 위험) |
| **충돌 처리** | 예외 발생 (`Exception`) -> 롤백 -> 재시도 필요 | 대기 (`Wait`) -> 순차 처리 -> 성공 |
| **대표 예시** | 게시판 수정, 프로필 업데이트 | 선착순 예매, 재고 차감, 계좌 이체 |

---

## 🚀 Step 0: 문제 상황 (락 미적용)

### 🧪 1. 실험 시나리오 (Experimental Scenario)
- **테스트 코드**: `동시성_테스트_1_낙관적_락.java` (JPA @Version 주석 처리 후 실행)
- **대상**: 1개 좌석 (Seat ID: 1)
- **부하**: 30명의 스레드가 동시에 예약 API 호출

### ❌ 2. 잘못된 구현 방식 (The Wrong Way)
아무런 보호 장치 없이 일반적인 조회와 수정을 반복하는 방식입니다.

```java
// [Service]
@Transactional
public void reserve(Long seatId) {
    Seat seat = seatRepository.findById(seatId).orElseThrow(); // 누구나 동시에 조회 가능
    seat.reserve(); // 각자 메모리 상에서 상태 변경
    // 커밋 시점에 마지막에 들어온 요청이 덮어쓰거나 중복 생성됨 (Race Condition)
}
```

### ✅ 3. 실험 결과 (실패)
데이터 정합성이 완전히 깨지는 현상이 발생함. (중복 예약 발생)

#### [수치 결과]
| 항목 | 결과값 | 비고 |
| :--- | :--- | :--- |
| **성공 횟수** | 10건 | **치명적 오류**: 1건이어야 함 |
| **최종 예약 건수** | **10건** | **중복 예약 발생 (Race Condition)** |

---

## 🚀 Step 1: 낙관적 락 (Optimistic Lock)

### 🧪 1. 실험 시나리오 (Experimental Scenario)
- **테스트 코드**: `동시성_테스트_1_낙관적_락.java`
- **대상**: 1개 좌석 (Seat ID: 1)
- **부하**: 30명의 스레드가 동시에 예약 API 호출

### 🛠️ 2. 구현 방법 (How to Apply)
엔티티에 `@Version` 컬럼을 추가하는 것만으로 애플리케이션 레벨의 체크 로직이 활성화됩니다.

```java
// [Entity]
@Version // JPA가 제공하는 낙관적 락 메커니즘
private Long version;
```

### 💡 3. 동작 원리 및 SQL
수정 쿼리 시점에 자동으로 버전 체크 조건이 붙습니다.
```sql
update seats 
set status='RESERVED', version=1 
where id=1 and version=0; -- 처음 읽은 버전이 0일 때만 성공
```

### ✅ 4. 실험 결과 및 분석
*   **성공 횟수**: 1건
*   **실패 횟수**: 29건 (ObjectOptimisticLockingFailureException 발생)
*   **결론**: 데이터 정합성은 보장하나, 충돌 시 사용자에게 에러를 반환하므로 선착순 예매에는 한계가 있음.

---

## 🚀 Step 2: 비관적 락 (Pessimistic Lock)

### 🧪 1. 실험 시나리오 (Experimental Scenario)
- **테스트 코드**: `동시성_테스트_2_비관적_락.java`
- **대상**: 1개 좌석 (Seat ID: 1)
- **부하**: 30명의 스레드가 동시에 예약 API 호출

### 🛠️ 2. 구현 방법 (How to Apply)
Spring Data JPA에서 비관적 락을 거는 방법은 크게 두 가지가 있습니다.

#### 방법 A: @Lock 어노테이션 사용 (권장)
JPA가 제공하는 `@Lock` 어노테이션을 사용하여 쿼리 생성 시점에 락 모드를 지정합니다. 이 방식을 쓰면 JPA가 SQL 끝에 자동으로 `FOR UPDATE`를 추가해 줍니다.

```java
// [Repository]
public interface SeatRepository extends JpaRepository<Seat, Long> {
    
    @Lock(LockModeType.PESSIMISTIC_WRITE) // 핵심: 비관적 락 모드 지정
    @Query("SELECT s FROM Seat s WHERE s.id = :id")
    Optional<Seat> findByIdWithPessimisticLock(@Param("id") Long id);
}
```

### 💡 3. 동작 원리 및 SQL
데이터를 읽는 시점부터 DB가 다른 스레드의 접근을 차단합니다.
```sql
/* 방법 A 적용 시 실행되는 실제 SQL */
select s1_0.id, ... 
from seats s1_0 
where s1_0.id=? 
for update; -- DB 엔진이 해당 행(Row)을 꽉 잡음 (자물쇠)
```

### ✅ 4. 결론 (Conclusion)
*   **비관적 락은 쿼리로 해결한다**: 코드 로직이 아니라 DB 엔진의 힘을 빌려 **줄을 세우는 방식**이다.
*   **장점**: 낙관적 락보다 정합성이 강력하고, 불필요한 예외 재시도 로직이 필요 없다.
*   **단점**: 대기 시간이 길어지면 DB 전체 성능에 영향을 준다.

---

## ⚠️ 락(Lock)의 한계와 현실적인 문제

낙관적 락과 비관적 락을 통해 데이터 정합성은 확보했으나, 대규모 트래픽(예: 10,000명 동시 접속) 상황에서는 다음과 같은 **치명적인 한계**가 발생한다.

### 1. 사용자 경험(UX)의 파괴: "만 명 중 한 명만 성공"
- 현재 방식은 1명이 락을 잡고 있는 동안 나머지는 대기하거나 에러를 받는다.
- 만 명의 사용자 중 9,999명은 "이미 예약된 좌석입니다"라는 무뚝뚝한 실패 메시지를 받고 다시 광클을 시도해야 한다. (광클 전쟁 유발)

### 2. 서버 자원 고갈: "DB 커넥션 풀 마비"
- 비관적 락(`FOR UPDATE`)은 DB 커넥션을 점유한 채로 대기한다.
- 동시 요청이 많아지면 모든 커넥션이 락 대기에 빠지게 되어, 예약과 상관없는 다른 API(공연 조회 등)까지 모두 먹통이 되는 **'서버 마비'** 상태에 이른다.

### 💡 해결의 방향: Redis 분산 락과 대기열
- **체력 강화 (Step 3)**: DB보다 훨씬 가볍고 빠른 **Redis**에서 락을 처리하여 DB 부하를 원천 차단한다.
- **질서 확립 (Phase 3)**: 단순히 실패시키는 것이 아니라, **대기열(Queue)**을 도입하여 사용자에게 대기 순번을 부여하고 순차적으로 처리하는 UX를 제공한다.

---

## 🚀 Step 3: Redis 분산 락 (Distributed Lock)

### 🧪 Step 3-1: 첫 번째 시도 (실패 사례 - 30/30 성공) ❌

#### 1. 실험 시나리오
- **테스트 코드**: `동시성_테스트_3_분산_락.java`
- **부하**: 30명의 스레드가 동시에 예약 API 호출
- **결과**: **30명 전원 예약 성공 (중복 예약 발생)**

#### 2. 원인 분석 (The Mystery of 30 Successes)
Redis 락을 획득했음에도 불구하고 왜 정합성이 깨졌을까? 여기에는 두 가지 치명적인 함정이 있었다.

**함정 1: 락 해제 시점 vs 트랜잭션 커밋 시점**
- **문제**: Redis 락은 로직이 끝나자마자 `finally` 블록에서 해제된다. 하지만 `@Transactional`에 의한 DB 커밋은 그 이후에 발생한다.
- **현상**: Thread A가 락을 해제하는 순간, 아직 DB에는 데이터가 반영(Commit)되지 않았다. 이때 대기하던 Thread B가 즉시 락을 잡고 진입하면, B는 여전히 `AVAILABLE` 상태의 데이터를 읽게 된다.

**함정 2: 스프링 프록시의 한계 (Internal Call)**
- **문제**: `createReservationWithDistributedLock` 내부에서 `this.createReservation()`을 호출하면, 스프링의 AOP 프록시가 작동하지 않아 `@Transactional`이 무시된다.
- **현상**: 각 DB 작업이 개별 트랜잭션으로 돌거나 커밋 시점이 모호해져서 락의 보호를 전혀 받지 못하게 된다.

#### 3. 교훈 (Lesson Learned)
> **"분산 락의 해제 시점은 반드시 트랜잭션의 커밋 시점보다 늦어야 한다."**
> 또한, 트랜잭션 전파를 위해 별도의 Facade 클래스를 두거나 스프링 빈의 외부 호출을 이용해야 한다.

---

### ✅ Step 3-2: 두 번째 시도 (성공 사례 - Facade 패턴 도입)

#### 1. Facade(파사드) 패턴이란?
'건물의 정면'이라는 뜻으로, 내부의 복잡한 로직들을 하나의 겉껍데기 클래스로 감싸서 밖에서는 단순하게 보이게 만드는 디자인 패턴이다.

#### 2. 왜 Facade가 필요한가? (트랜잭션의 함정)
스프링의 `@Transactional`은 메서드가 완전히 끝날 때 DB에 내용을 저장(Commit)한다.
- **Service 내부에서 락을 걸면**: 메서드 끝에서 락을 먼저 풀고, 그 **다음에** DB 저장이 일어난다. (그 사이 찰나에 다른 놈이 들어와서 사고 발생!)
- **Facade를 사용하면**: 
  1. Facade에서 락을 잡는다.
  2. Service의 트랜잭션 메서드를 부른다. (DB 저장까지 완벽히 끝날 때까지 기다림)
  3. **DB 저장이 확실히 끝난 뒤에** Facade에서 락을 푼다.

#### 3. 해결 전략: RedissonLockFacade 전체 코드
생략 없이 실제 구현된 코드를 통해 락과 트랜잭션의 조율 과정을 확인한다.

```java
@Component
@RequiredArgsConstructor
public class RedissonLockFacade {

    private final RedissonClient redissonClient;
    private final ReservationService reservationService;

    public ReservationResponse createReservation(ReservationRequest request) {
        String lockKey = "lock:seat:" + request.seatId();
        RLock lock = redissonClient.getLock(lockKey);

        try {
            // [중요 설계 변경] 짐작에 의한 숫자(Magic Number) 배제
            // 1. Wait Time: 비즈니스 타임아웃 정책에 따라 설정 (ex: 10초)
            // 2. Lease Time: -1로 설정하여 Redisson Watchdog(감시견)에게 관리를 위임
            boolean available = lock.tryLock(10, -1, TimeUnit.SECONDS);

            if (!available) {
                throw new RuntimeException("락 획득 실패: 서버가 바쁩니다. 잠시 후 다시 시도해주세요.");
            }

            return reservationService.createReservation(request);

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}
```

---

## 🌟 [Special] Magic Number를 배제한 자율적 시스템 설계 (중요)

이 섹션은 단순히 코드를 짜는 것을 넘어, **"진정한 프로그램이란 무엇인가"**에 대한 엔지니어링 철학을 다룬다.

### 1. 짐작하는 숫자의 위험성 (Anti-Programming)
초기에 작성했던 `lock.tryLock(10, 2, TimeUnit.SECONDS)` 코드에서 `2초`라는 숫자는 개발자의 **'짐작'**에 불과하다. 

#### ❌ 나쁜 예시 (Bad Practice: Guessing Numbers)
```java
// 로직이 2초 안에 끝날 것이라고 '짐작'하여 하드코딩
// 만약 DB가 느려져 2.1초가 걸리면? -> 락이 풀리고 중복 데이터 발생! 정합성 파괴!
boolean available = lock.tryLock(10, 2, TimeUnit.SECONDS); 
```

#### ✅ 좋은 예시 (Best Practice: Autonomous Management)
```java
// 1. 대기 시간은 정책(Policy)으로 관리
private static final long MAX_WAIT_TIME = 10L; 

// 2. 점유 시간은 -1로 설정하여 시스템(Watchdog)이 스스로 판단하게 함
// 로직이 얼마나 걸리든 안전하게 정합성 유지
boolean available = lock.tryLock(MAX_WAIT_TIME, -1, TimeUnit.SECONDS);
```

### 2. 설정 파일(`application.yml`)조차 하드코딩이다
값을 설정 파일로 옮기는 행위는 관리의 편의성을 높일 뿐, 결국 사람이 정한 **'정적 수치'**라는 본질은 변하지 않는다. 진정한 해결책은 시스템이 상황에 맞춰 **'스스로 판단'**하게 만드는 것이다.

### 3. 자율적 해결책: Redisson Watchdog (감시견) 🐕
우리는 `leaseTime`을 `-1`로 설정함으로써 이 문제를 우아하게 해결했다.
- **작동 원리**: 로직이 실행 중인 동안 Redisson이 주기적으로 락의 유효시간을 연장한다. 
- **장점**: 로직이 0.1초 만에 끝나든, 10초가 걸리든 **상황에 맞춰 락 유지 시간을 스스로 조절**한다.
- **안전성**: 만약 서버가 갑자기 죽어 연장 신호를 못 보내면, 그때서야 락을 해제하여 데드락(Deadlock)을 방지한다.

### 💡 핵심 교훈: "상황을 단정 짓지 말고, 시스템이 흐르게 하라"
> **"설정값은 최소화하고, 자율적인 메커니즘(Watchdog 등)을 우선시하는 설계가 대규모 분산 시스템에서 살아남는 프로그래밍 방식이다."**

---

### ✅ 4. 최종 결론 (Conclusion)

- **비관적 락**은 DB 자원을 많이 소모하지만 설정이 간편하다.
- **Redis 분산 락**은 설정이 복잡(Facade 필요)하지만, DB 부하를 획득 시점 이전에 차단할 수 있어 **대규모 트래픽에 훨씬 유리**하다.

---

## 🚀 Step 4: Kafka 기반 비동기 대기열 (Async Queue)

### 💡 1. 왜 '대기열' 방식인가? (The Paradigm Shift)
지금까지의 **락(Lock)** 방식은 "한 놈만 들어와, 나머지는 다 실패야"라는 배제적 방식입니다. 이는 만 명의 사용자가 동시에 접속했을 때 9,999명에게 불쾌한 경험을 주며 서버 자원을 고갈시킵니다.
- **Before (Blocking)**: 클라이언트가 요청을 보내면 DB 예약이 끝날 때까지 스레드가 대기(Block)함.
- **After (Event-Driven)**: 클라이언트 요청을 즉시 Kafka에 담고 응답(Accepted). 실제 처리는 서버가 감당 가능한 속도로 나중에 수행.

---

### 🛠️ 2. 구현 방법 (How to Apply)

#### 2.1. 요청 수집 (Producer)
사용자의 요청을 이벤트 객체로 감싸 Kafka로 쏘아 올립니다. 이때 **`seatId`를 메시지 키(Key)**로 사용하는 것이 핵심입니다.

```java
// [KafkaReservationProducer.java]
public void send(ReservationEvent event) {
    // seatId를 키로 설정하여 동일 좌석 요청은 무조건 같은 파티션(순서 보장)으로 전송
    kafkaTemplate.send(topic, String.valueOf(event.getSeatId()), event);
}
```

#### 2.2. 비동기 처리 (Consumer)
Kafka에서 메시지를 하나씩 꺼내어 실제 예약 로직을 수행합니다. 지정된 `lockType`에 따라 앞선 Step 1~2의 로직을 재사용합니다.

```java
// [KafkaReservationConsumer.java]
@KafkaListener(topics = "ticket-reservation-events", groupId = "ticket-group")
public void consume(ReservationEvent event) {
    // 1. 상태를 PROCESSING으로 변경
    queueService.setStatus(userId, seatId, "PROCESSING");
    
    // 2. 실제 예약 서비스 호출 (Pessimistic or Optimistic)
    reservationService.createReservationWithPessimisticLock(request);
    
    // 3. 성공 시 실시간 알림 전송
    sseManager.send(userId, seatId, "SUCCESS");
}
```

#### 2.3. 실시간 결과 통보 (SSE)
사용자가 결과를 기다리지 않도록 서버에서 클라이언트로 데이터를 밀어주는 SSE를 적용했습니다.

```java
// [SseEmitterManager.java]
public void send(Long userId, Long seatId, String status) {
    String key = userId + ":" + seatId;
    SseEmitter emitter = emitters.get(key);
    if (emitter != null) {
        emitter.send(SseEmitter.event().name("RESERVATION_STATUS").data(status));
        emitter.complete(); // 임무 완수 후 연결 종료
    }
}
```

### ✅ 3. 코드 변환 대조 (Sync to Async Migration)

#### ❌ Before: 동기식 요청 처리 (Blocking)
클라이언트가 요청을 보내면, DB 작업이 끝날 때까지 서버 스레드가 붙잡혀 있습니다.
```java
// [Controller]
@PostMapping("/v1/optimistic")
public ResponseEntity<ReservationResponse> createReservation(@RequestBody ReservationRequest request) {
    // 즉시 서비스 호출 -> DB 작업 완료까지 대기(Block)
    return ResponseEntity.ok(reservationService.createReservation(request));
}
```

#### ✅ After: 비동기 이벤트 기반 처리 (Non-blocking)
요청을 받자마자 Kafka에 적재하고 즉시 응답합니다. 실제 처리는 별도 컨슈머 스레드에서 수행됩니다.
```java
// [Controller]
@PostMapping("/v4/queue")
public ResponseEntity<String> createAsyncReservation(@RequestBody ReservationRequest request) {
    // 1. Redis에 초기 상태 저장
    queueService.setStatus(request.userId(), request.seatId(), "PENDING");
    
    // 2. Kafka로 이벤트 발행 (즉시 리턴)
    kafkaProducer.send(ReservationEvent.of(request.userId(), request.seatId(), OPTIMISTIC));
    
    return ResponseEntity.accepted().body("Request Enqueued");
}
```

---

### 💡 4. 핵심 설계 결정 및 정합성 보장 (ADR)

| 결정 사항 | 설계 내용 | 공학적 이유 |
| :--- | :--- | :--- |
| **Partition Key** | `seatId` | 동일 좌석에 대한 경합을 단일 컨슈머 스레드에서 순차적으로 처리하기 위함 (물리적 순서 보장) |
| **Status Store** | Redis | 비동기 처리 중 사용자가 언제든 상태를 조회(`Polling`)할 수 있도록 초고속 저장소 활용 |
| **Notification** | SSE | 폴링에 의한 불필요한 네트워크 트래픽을 줄이고 사용자에게 즉각적인 당첨 경험 제공 |

---

## 🚀 Step 5: Redis Sorted Set 기반 실시간 대기열

### 💡 1. 핵심 매커니즘: Redis Sorted Set (ZSET)
- **Key**: `waiting-queue:concert:{concertId}` (콜론`:`을 사용하여 계층 구조 표현)
- **Member**: `userId` (중복 불가능한 식별자)
- **Score**: `System.currentTimeMillis()` (도착 시간 기반 자동 정렬)

### 🛠️ 2. Redis Z-명령어 상세 및 Java 구현 (Deep Dive)

| 명령어 (Redis CLI) | 설명 (Description) | Java 활용 예시 (StringRedisTemplate) |
| :--- | :--- | :--- |
| **ZADD** | 대기열 진입 (이름표+점수 추가) | `opsForZSet().add(key, userId, score)` |
| **ZRANK** | 내 순위 조회 (0번부터 시작) | `opsForZSet().rank(key, userId)` |
| **ZRANGE** | 특정 범위 대기자 추출 | `opsForZSet().range(key, start, stop)` |
| **ZREM** | 대기열에서 제거 (입장 처리) | `opsForZSet().remove(key, userId)` |
| **ZCARD** | 현재 대기자 총 인원수 | `opsForZSet().size(key)` |

#### Java 구현 예시 (Snippet)
```java
// 1. 대기열 진입
String key = "waiting-queue:concert:1";
redisTemplate.opsForZSet().add(key, "user_101", System.currentTimeMillis());

// 2. 내 순번 조회 (0번부터이므로 +1)
Long rank = redisTemplate.opsForZSet().rank(key, "user_101");
System.out.println("내 대기 순번: " + (rank + 1));

// 3. 상위 10명 추출하여 활성화
Set<String> activeUsers = redisTemplate.opsForZSet().range(key, 0, 9);
```

---

## 🚀 Step 6: 유입량 제어 전략 (Throttling)

### 💡 1. 개요 (Overview)
대기열 시스템의 완성은 단순히 줄을 세우는 것이 아니라, **서버가 감당 가능한 만큼만 들여보내는 것**입니다. 이를 위해 두 가지 제어 장치를 도입합니다.

### 🛠️ 2. 핵심 제어 매커니즘 (Control Mechanisms)

#### 2.1. 진입 차단 (Throttling) - "입구 컷"
- **목적**: 대기열 자체가 너무 길어져 Redis 메모리가 고갈되거나, 대기 시간이 수 시간을 넘어가 의미가 없어지는 상황 방지.
- **로직**: `ZCARD` 명령어로 현재 대기 인원을 체크하여 임계치(Threshold) 초과 시 진입 거부.
- **기준**: `MAX_QUEUE_SIZE = 50,000` (설정 가능)

#### 2.2. 유입량 동적 조절 (Dynamic Batching) - "수도꼭지"
- **목적**: 서버 상태가 좋을 때는 많이, 나쁠 때는 적게 통과시킴.
- **로직**: 스케줄러가 활성화하는 인원(`activateCount`)을 고정값이 아닌 변수로 관리.
- **고도화 방향**: CPU 점유율, DB 커넥션 풀 잔여량 등과 연동 (우선은 관리자 설정값 기반으로 시작).

#### 2.3. ACTIVE 토큰 검증 (Security) - "암행어사"
- **목적**: 대기열을 우회하여 직접 예약 API를 호출하는 어뷰징 차단.
- **로직**: `ActiveUserInterceptor`를 구현하여, 예약 API 호출 시 Redis에 `active-user:{id}` 키가 존재하는지 확인.

---

### 🔄 3. 상태 전이도 (State Transition)

1.  **WAITING**: ZSET에 점수와 함께 등록됨.
2.  **CHECK_THROTTLE**: 진입 전 `ZCARD`로 현재 대기열 크기 확인.
3.  **ACTIVE**: 스케줄러에 의해 ZSET에서 제거되고 String 키(TTL 5분)로 복사됨.
4.  **RESERVING**: 실제 예약 API 호출 (Interceptor에서 ACTIVE 여부 검증).
