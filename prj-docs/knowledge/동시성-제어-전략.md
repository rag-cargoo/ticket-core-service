# 동시성 제어 및 고성능 대기열 전략 (Concurrency & Queue Strategy)

> **Purpose**: 선착순 예약 시스템의 정합성 해결부터 대기열 설계까지의 기술적 여정
> **Date**: 2026-02-07

---

## 목차 (Table of Contents)
- 이론 배경: 낙관적 락 vs 비관적 락
- Step 0: 문제 상황 (락 미적용)
- Step 1: 낙관적 락 (Optimistic Lock)
- Step 2: 비관적 락 (Pessimistic Lock)
- Step 3: Redis 분산 락 (Distributed Lock)
- Step 4: Kafka 기반 비동기 대기열 (Async Queue)
- Step 5: Redis Sorted Set 기반 실시간 대기열
- Step 6: 유입량 제어 전략 (Throttling)

---


## Step 0: 문제 상황 (락 미적용)
---
> ### 1. 실험 시나리오
> - **대상**: 1개 좌석 (Seat ID: 1)
> - **부하**: 30명의 스레드가 동시에 예약 API 호출
>
> ### 2. 잘못된 구현 방식
> - 아무런 보호 장치 없이 일반적인 조회와 수정을 반복하는 방식
> ```java
> @Transactional
> public void reserve(Long seatId) {
>     Seat seat = seatRepository.findById(seatId).orElseThrow();
>     seat.reserve();
> }
> ```
>
> ### 3. 실험 결과 (실패)
> - **성공 횟수**: 10건 (중복 예약 발생)
> - **결론**: Race Condition 발생으로 정합성 파괴

---


## Step 1: 낙관적 락 (Optimistic Lock)
---
> ### 1. 구현 방법
> - 엔티티에 `@Version` 컬럼을 추가하여 애플리케이션 레벨 체크 활성화
> ```java
> @Version 
> private Long version;
> ```
>
> ### 2. 동작 원리 및 SQL
> - 수정 쿼리 시점에 자동으로 버전 체크 조건 부여
> ```sql
> update seats set status='RESERVED', version=1 where id=1 and version=0;
> ```
>
> ### 3. 실험 결과 및 분석
> - **성공 횟수**: 1건
> - **결론**: 정합성은 보장하나, 29명에게 예외를 반환하므로 사용자 경험이 좋지 않음

---


## Step 2: 비관적 락 (Pessimistic Lock)
---
> ### 1. 구현 방법
> - `SELECT ... FOR UPDATE`를 사용하여 데이터를 읽는 시점부터 DB 물리적 락 점유
> ```java
> @Lock(LockModeType.PESSIMISTIC_WRITE)
> @Query("SELECT s FROM Seat s WHERE s.id = :id")
> Optional<Seat> findByIdWithPessimisticLock(@Param("id") Long id);
> ```
>
> ### 2. 실험 결과 및 분석
> - **장점**: 강력한 정합성 보장, 별도 재시도 로직 불필요
> - **단점**: 대기 시간이 길어지면 DB 커넥션 풀 마비 위험

---


## Step 3: Redis 분산 락 (Distributed Lock)
---
> ### 1. Facade 패턴 도입 배경
> - 락 해제 시점과 트랜잭션 커밋 시점의 불일치를 해결하기 위해 별도의 Facade 클래스 사용
>
> ### 2. Magic Number를 배제한 자율적 설계 (중요)
> - **짐작하는 숫자 배제**: `lock.tryLock(10, 2, TimeUnit.SECONDS)`에서 `2초`와 같은 하드코딩 수치는 위험함
> - **자율적 해결책**: `leaseTime`을 `-1`로 설정하여 **Redisson Watchdog**에게 관리를 위임
>   - **작동 원리**: 로직 실행 중 주기적으로 락 유효시간 자동 연장
>   - **핵심 교훈**: "상황을 단정 짓지 말고, 시스템이 흐르게 하라"
>
> ### 3. 구현 코드 (RedissonLockFacade)
> ```java
> public ReservationResponse createReservation(ReservationRequest request) {
>     RLock lock = redissonClient.getLock("lock:seat:" + request.seatId());
>     try {
>         boolean available = lock.tryLock(10, -1, TimeUnit.SECONDS);
>         if (!available) throw new RuntimeException("락 획득 실패");
>         return reservationService.createReservation(request);
>     } finally {
>         if (lock.isHeldByCurrentThread()) lock.unlock();
>     }
> }
> ```

---


## Step 4: Kafka 기반 비동기 대기열 (Async Queue)
---
> ### 1. 패러다임의 전환
> - **Before (Blocking)**: 클라이언트 요청 시 DB 작업 완료까지 스레드 대기
> - **After (Event-Driven)**: 요청을 Kafka에 담고 즉시 응답, 처리는 감당 가능한 속도로 나중에 수행
>
> ### 2. 핵심 설계 결정 (ADR)
> - **Partition Key**: `seatId`를 사용하여 동일 좌석 요청은 동일 파티션에서 순차 처리 보장
> - **Notification**: SSE(Server-Sent Events)를 통해 비동기 처리 결과를 실시간 통보

---


## Step 5: Redis Sorted Set 기반 실시간 대기열
---
> ### 1. 핵심 매커니즘: ZSET (Sorted Set)
> - **Key**: `waiting-queue:concert:{id}`
> - **Score**: `System.currentTimeMillis()` (시간순 자동 정렬)
> - **장점**: 100만 명 중 내 순위를 $O(\log N)$ 속도로 초고속 조회 가능
>
> ### 2. Redis 명령어 활용
> - `ZADD`: 대기열 진입
> - `ZRANK`: 내 앞의 대기 인원 조회
> - `ZRANGE`: 상위 N명 추출하여 활성화(ACTIVE) 전환

---


## Step 6: 유입량 제어 전략 (Throttling)
---
> ### 1. 핵심 제어 장치
> - **진입 차단 (Throttling)**: `ZCARD`로 현재 대기 인원 체크, 임계치(예: 50,000) 초과 시 진입 거부
> - **유입량 동적 조절**: 서버 부하에 따라 활성화 인원수를 가변적으로 운영
> - **ACTIVE 토큰 검증**: 인터셉터에서 유효한 권한인지 검증하여 어뷰징 원천 차단
>
> ### 2. 상태 전이도 (State Transition)
> - `WAITING (ZSET)` -> `CHECK_THROTTLE` -> `ACTIVE (String + TTL)` -> `RESERVING (API 호출)`
---