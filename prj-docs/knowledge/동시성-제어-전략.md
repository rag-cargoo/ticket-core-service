# 동시성 제어 및 고성능 대기열 전략 (Concurrency & Queue Strategy)

> **Purpose**: 선착순 좌석 예약 시스템의 정합성 문제 해결부터 초고속 대기열 설계까지의 기술적 여정 기록
> **Date**: 2026-02-07

---

## 📂 목차 (Table of Contents)

└─ 💡 [이론 배경: 낙관적 락 vs 비관적 락](#-이론-배경-낙관적-락-vs-비관적-락-theory)
└─ 🚀 [Step 0: 문제 상황 (락 미적용)](#-step-0-문제-상황-락-미적용)
└─ 🚀 [Step 1: 낙관적 락 (Optimistic Lock)](#-step-1-낙관적-락-optimistic-lock)
└─ 🚀 [Step 2: 비관적 락 (Pessimistic Lock)](#-step-2-비관적-락-pessimistic-lock)
   └─ ⚠️ [락(Lock)의 한계와 현실적인 문제](#-락lock의-한계와-현실적인-문제)
└─ 🚀 [Step 3: Redis 분산 락 (Distributed Lock)](#-step-3-redis-분산-락-distributed-lock)
   └─ 💡 [Magic Number 배제 및 자율적 설계 (Watchdog)](#-magic-number를-배제한-자율적-시스템-설계-중요)
└─ 🚀 [Step 4: Kafka 기반 비동기 대기열 (Async Queue)](#-step-4-kafka-기반-비동기-대기열-async-queue)
└─ 🚀 [Step 5: Redis Sorted Set 기반 실시간 대기열](#-step-5-redis-sorted-set-기반-실시간-대기열)
└─ 🚀 [Step 6: 유입량 제어 전략 (Throttling)](#-step-6-유입량-제어-전략-throttling)

---

## 💡 이론 배경: 낙관적 락 vs 비관적 락 (Theory)

| 특징 | 낙관적 락 (Optimistic Lock) | 비관적 락 (Pessimistic Lock) |
| :--- | :--- | :--- |
| **기본 사상** | "충돌은 드물 거야. 충돌 나면 그때 해결하자." | "충돌은 빈번할 거야. 아예 못 건드리게 막자." |
| **구현 방식** | **애플리케이션 로직**: 버전 컬럼(`@Version`) 비교 | **DB 쿼리**: `SELECT ... FOR UPDATE` 물리적 락 |
| **성능 (DB)** | **높음** (락 대기 없음) | **낮음** (대기 발생, 데드락 위험) |
| **대표 예시** | 게시판 수정, 프로필 업데이트 | 선착순 예매, 재고 차감, 계좌 이체 |

---

## 🚀 Step 0: 문제 상황 (락 미적용)

### 🧪 실험 시나리오
- **대상**: 1개 좌석 (Seat ID: 1)
- **부하**: 30명의 스레드가 동시에 예약 API 호출

### ❌ 잘못된 구현 방식
아무런 보호 장치 없이 조회와 수정을 반복하는 방식입니다.
```java
@Transactional
public void reserve(Long seatId) {
    Seat seat = seatRepository.findById(seatId).orElseThrow();
    seat.reserve();
}
```

### ✅ 실험 결과 (실패)
- **성공 횟수**: 10건 (중복 예약 발생)
- **결론**: Race Condition에 의해 데이터 정합성이 완전히 파괴됨.

---

## 🚀 Step 1: 낙관적 락 (Optimistic Lock)

### 🛠️ 구현 방법
엔티티에 `@Version` 컬럼을 추가하여 JPA 레벨의 체크 로직을 활성화합니다.
```java
@Version 
private Long version;
```

### 💡 동작 원리 및 SQL
```sql
UPDATE seats SET status='RESERVED', version=1 WHERE id=1 AND version=0;
```

### ✅ 실험 결과 및 분석
- **성공 횟수**: 1건
- **결론**: 정합성은 보장하나, 29명에게 예외를 던지므로 재시도 로직이 없으면 사용자 경험이 좋지 않음.

---

## 🚀 Step 2: 비관적 락 (Pessimistic Lock)

### 🛠️ 구현 방법
`SELECT ... FOR UPDATE`를 사용하여 데이터를 읽는 시점부터 DB 락을 점유합니다.
```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT s FROM Seat s WHERE s.id = :id")
Optional<Seat> findByIdWithPessimisticLock(@Param("id") Long id);
```

### ✅ 실험 결과 및 분석
- **장점**: 강력한 정합성, 별도의 예외 처리 로직 불필요.
- **단점**: 대기 시간이 길어지면 DB 커넥션 풀 마비 위험.

---

## ⚠️ 락(Lock)의 한계와 현실적인 문제

1. **UX 파괴**: "만 명 중 한 명만 성공, 나머지는 무조건 실패"
2. **서버 자원 고갈**: DB 커넥션이 락 대기에 묶여 전체 서비스 마비.
> **해결 방향**: DB보다 가벼운 **Redis** 활용 및 실패가 아닌 **대기(Queue)**로 패러다임 전환.

---

## 🚀 Step 3: Redis 분산 락 (Distributed Lock)

### 💡 Facade 패턴 도입
락 해제 시점이 트랜잭션 커밋보다 늦어야 하므로 `RedissonLockFacade`를 통해 트랜잭션을 감쌉니다.

### 🌟 Magic Number를 배제한 자율적 시스템 설계 (중요)
1. **짐작하는 숫자 배제**: `leaseTime`을 `-1`로 설정.
2. **Redisson Watchdog 🐕**: 로직 실행 중 락 시간을 스스로 연장하여 정합성을 자율적으로 보호.
3. **핵심 교훈**: "상황을 단정 짓지 말고, 시스템이 흐르게 하라."

---

## 🚀 Step 4: Kafka 기반 비동기 대기열 (Async Queue)

### 💡 패러다임의 전환: "락(Lock)"에서 "대기열(Queue)"로
- **Before**: "한 놈만 들어와! 나머지는 꺼져!" (배제)
- **After**: "일단 줄 서세요. 순서대로 처리해 드릴게요." (포용)

### 🛠️ 구현 매커니즘
- **Producer**: `seatId`를 파티션 키로 사용하여 순서 보장 전송.
- **Consumer**: 서버가 감당 가능한 속도로 메시지를 꺼내어 예약 수행.
- **Notification**: SSE(Server-Sent Events)를 통해 실시간 결과 통보.

---

## 🚀 Step 5: Redis Sorted Set 기반 실시간 대기열

### 💡 핵심 매커니즘: ZSET (Sorted Set)
- **Key**: `waiting-queue:concert:{id}`
- **Member**: `userId`
- **Score**: `System.currentTimeMillis()` (시간순 자동 정렬)

### 🛠️ Redis Z-명령어 활용법
| 명령어 | 용도 | Java 구현 |
| :--- | :--- | :--- |
| **ZADD** | 대기열 진입 | `opsForZSet().add(key, userId, time)` |
| **ZRANK** | 실시간 순번 조회 | `opsForZSet().rank(key, userId)` |
| **ZRANGE** | 활성화 대상 추출 | `opsForZSet().range(key, 0, n)` |
| **ZREM** | 대기열 탈출 | `opsForZSet().remove(key, userId)` |

---

## 🚀 Step 6: 유입량 제어 전략 (Throttling)

### 💡 핵심 제어 매커니즘
1. **진입 차단 (Throttling)**: `ZCARD`로 현재 대기열 크기 체크, 임계치 초과 시 진입 거부.
2. **유입량 동적 조절 (Dynamic Batching)**: 서버 부하에 따라 활성화 인원수 가변 운영.
3. **ACTIVE 토큰 검증 (Security)**: 인터셉터에서 `active-user:{id}` 존재 여부를 검증하여 어뷰징 차단.

### 🔄 상태 전이 (State Transition)
`WAITING (ZSET)` -> `CHECK_THROTTLE` -> `ACTIVE (String + TTL)` -> `RESERVING (API)`
