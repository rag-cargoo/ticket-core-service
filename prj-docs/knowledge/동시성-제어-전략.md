# 동시성 제어 전략 (Concurrency Control Strategy)

> **Purpose**: 선착순 좌석 예약 시스템에서 발생하는 데이터 정합성 문제 해결 및 성능 최적화 전략 기록
> **Date**: 2026-02-05


## 0. 이론 배경: 낙관적 락 vs 비관적 락 (Theory)
---
> [!NOTE]
> 
> | 특징 | 낙관적 락 (Optimistic Lock) | 비관적 락 (Pessimistic Lock) |
> | :--- | :--- | :--- |
> | **기본 사상** | "충돌은 드물 거야. 충돌 나면 그때 해결하자." | "충돌은 빈번할 거야. 아예 못 건드리게 막자." |
> | **구현 방식** | **애플리케이션 로직**: 버전 컬럼(`@Version`) 비교. | **DB 쿼리**: `SELECT ... FOR UPDATE`로 물리적 락. |
> | **성능 (DB)** | **높음** (락 대기 없음) | **낮음** (대기 발생, 데드락 위험) |
> | **충돌 처리** | 예외 발생 (`Exception`) -> 롤백 -> 재시도 필요 | 대기 (`Wait`) -> 순차 처리 -> 성공 |
> | **대표 예시** | 게시판 수정, 프로필 업데이트 | 선착순 예매, 재고 차감, 계좌 이체 |
> 
> 

##  실험 기록 순서 (Progress)
---
> [!NOTE]
> 1. [Step 0: 문제 상황 (락 미적용)](#step-0-문제-상황-락-미적용) - **Completed**
> 2. [Step 1: 낙관적 락 (Optimistic Lock)](#step-1-낙관적-락-optimistic-lock) - **Completed**
> 3. [Step 2: 비관적 락 (Pessimistic Lock)](#step-2-비관적-락-pessimistic-lock) - **Completed**
> 4. [Step 3: Redis 분산 락 (Distributed Lock)](#step-3-redis-분산-락-distributed-lock) - **Completed**
> 5. [Step 4: Kafka 기반 비동기 대기열 (Async Queue)](#step-4-kafka-기반-비동기-대기열-async-queue) - **Completed**
> 
> 

## Step 0: 문제 상황 (락 미적용)
---
> [!ATTENTION]
> 
> ### 1. 실험 시나리오 (Experimental Scenario)
> ---
>   - **테스트 코드**: `동시성_테스트_1_낙관적_락.java` (JPA @Version 주석 처리 후 실행)
>   - **대상**: 1개 좌석 (Seat ID: 1)
>   - **부하**: 30명의 스레드가 동시에 예약 API 호출
> 
> ### 2. 잘못된 구현 방식 (The Wrong Way)
> ---
> 아무런 보호 장치 없이 일반적인 조회와 수정을 반복하는 방식입니다.
> 
> ```java
> // [Service]
> @Transactional
> public void reserve(Long seatId) {
>     Seat seat = seatRepository.findById(seatId).orElseThrow(); // 누구나 동시에 조회 가능
>     seat.reserve(); // 각자 메모리 상에서 상태 변경
>     // 커밋 시점에 마지막에 들어온 요청이 덮어쓰거나 중복 생성됨 (Race Condition)
> }
> ```
> 
> ### 3. 실험 결과 (실패)
> ---
> 데이터 정합성이 완전히 깨지는 현상이 발생함. (중복 예약 발생)
> 
> #### [수치 결과]
> ---
> | 항목 | 결과값 | 비고 |
> | :--- | :--- | :--- |
> | **성공 횟수** | 10건 | **치명적 오류**: 1건이어야 함 |
> | **최종 예약 건수** | **10건** | **중복 예약 발생 (Race Condition)** |
> 
> 

## Step 1: 낙관적 락 (Optimistic Lock)
---
> [!TIP]
> 
> ### 1. 실험 시나리오 (Experimental Scenario)
> ---
>   - **테스트 코드**: `동시성_테스트_1_낙관적_락.java`
>   - **대상**: 1개 좌석 (Seat ID: 1)
>   - **부하**: 30명의 스레드가 동시에 예약 API 호출
> 
> ### 2. 구현 방법 (How to Apply)
> ---
> 엔티티에 `@Version` 컬럼을 추가하는 것만으로 애플리케이션 레벨의 체크 로직이 활성화됩니다.
> 
> ```java
> // [Entity]
> @Version // JPA가 제공하는 낙관적 락 메커니즘
> private Long version;
> ```
> 
> ### 3. 동작 원리 및 SQL
> ---
> 수정 쿼리 시점에 자동으로 버전 체크 조건이 붙습니다.
> ```sql
> update seats 
> set status='RESERVED', version=1 
> where id=1 and version=0; -- 처음 읽은 버전이 0일 때만 성공
> ```
> 
> ### 4. 실험 결과 및 분석
> ---
> *   **성공 횟수**: 1건
> *   **실패 횟수**: 29건 (ObjectOptimisticLockingFailureException 발생)
> *   **결론**: 데이터 정합성은 보장하나, 충돌 시 사용자에게 에러를 반환하므로 선착순 예매에는 한계가 있음.
> 
> 

## Step 2: 비관적 락 (Pessimistic Lock)
---
> [!TIP]
> 
> ### 1. 실험 시나리오 (Experimental Scenario)
> ---
>   - **테스트 코드**: `동시성_테스트_2_비관적_락.java`
>   - **대상**: 1개 좌석 (Seat ID: 1)
>   - **부하**: 30명의 스레드가 동시에 예약 API 호출
> 
> ### 2. 구현 방법 (How to Apply)
> ---
> Spring Data JPA에서 비관적 락을 거는 방법은 크게 두 가지가 있습니다.
> 
> #### 방법 A: @Lock 어노테이션 사용 (권장)
> ---
> JPA가 제공하는 `@Lock` 어노테이션을 사용하여 쿼리 생성 시점에 락 모드를 지정합니다. 이 방식을 쓰면 JPA가 SQL 끝에 자동으로 `FOR UPDATE`를 추가해 줍니다.

```java
// [Repository]
public interface SeatRepository extends JpaRepository<Seat, Long> {
    
    @Lock(LockModeType.PESSIMISTIC_WRITE) // 핵심: 비관적 락 모드 지정
    @Query("SELECT s FROM Seat s WHERE s.id = :id")
    Optional<Seat> findByIdWithPessimisticLock(@Param("id") Long id);
}
```

#### 방법 B: 쿼리에 직접 명시
어노테이션을 사용하지 않고, SQL 또는 JPQL 끝에 직접 락 키워드를 작성합니다. 하지만 JPA 환경에서는 일관성을 위해 `@Lock` 사용을 권장합니다.

### 3. 동작 원리 및 SQL
데이터를 읽는 시점부터 DB가 다른 스레드의 접근을 차단합니다.
```sql
/* 방법 A 적용 시 실행되는 실제 SQL */
select s1_0.id, ... 
from seats s1_0 
where s1_0.id=? 
for update; -- DB 엔진이 해당 행(Row)을 꽉 잡음 (자물쇠)
```

### 4. 결론 (Conclusion)
*   **비관적 락은 쿼리로 해결한다**: 코드 로직이 아니라 DB 엔진의 힘을 빌려 **줄을 세우는 방식**이다.
*   **장점**: 낙관적 락보다 정합성이 강력하고, 불필요한 예외 재시도 로직이 필요 없다.
*   **단점**: 대기 시간이 길어지면 DB 전체 성능에 영향을 준다.

---


##  락(Lock)만으로는 해결할 수 없는 현실적인 문제
---
> [!NOTE]
> 
> 낙관적 락과 비관적 락을 통해 데이터 정합성은 확보했으나, 대규모 트래픽(예: 10,000명 동시 접속) 상황에서는 다음과 같은 **치명적인 한계**가 발생한다.
> 
> ### 1. 사용자 경험(UX)의 파괴: "만 명 중 한 명만 성공"
> ---
>   - 현재 방식은 1명이 락을 잡고 있는 동안 나머지는 대기하거나 에러를 받는다.
>   - 만 명의 사용자 중 9,999명은 "이미 예약된 좌석입니다"라는 무뚝뚝한 실패 메시지를 받고 다시 광클을 시도해야 한다. (광클 전쟁 유발)
> 
> ### 2. 서버 자원 고갈: "DB 커넥션 풀 마비"
> ---
>   - 비관적 락(`FOR UPDATE`)은 DB 커넥션을 점유한 채로 대기한다.
>   - 동시 요청이 많아지면 모든 커넥션이 락 대기에 빠지게 되어, 예약과 상관없는 다른 API(공연 조회 등)까지 모두 먹통이 되는 **'서버 마비'** 상태에 이른다.
> 
> ###  해결의 방향: Redis 분산 락과 대기열
> ---
>   - **체력 강화 (Step 3)**: DB보다 훨씬 가볍고 빠른 **Redis**에서 락을 처리하여 DB 부하를 원천 차단한다.
>   - **질서 확립 (Phase 3)**: 단순히 실패시키는 것이 아니라, **대기열(Queue)**을 도입하여 사용자에게 대기 순번을 부여하고 순차적으로 처리하는 UX를 제공한다.
> 
> 

## Step 3: Redis 분산 락 (Distributed Lock)
---
> [!NOTE]
> 
> ### Step 3-1: 첫 번째 시도 (실패 사례 - 30/30 성공)
> ---
> 
> #### 1. 실험 시나리오
> ---
>   - **테스트 코드**: `동시성_테스트_3_분산_락.java`
>   - **부하**: 30명의 스레드가 동시에 예약 API 호출
>   - **결과**: **30명 전원 예약 성공 (중복 예약 발생)**
> 
> #### 2. 원인 분석 (The Mystery of 30 Successes)
> ---
> Redis 락을 획득했음에도 불구하고 왜 정합성이 깨졌을까? 여기에는 두 가지 치명적인 함정이 있었다.
> 
> **함정 1: 락 해제 시점 vs 트랜잭션 커밋 시점**
>   - **문제**: Redis 락은 로직이 끝나자마자 `finally` 블록에서 해제된다. 하지만 `@Transactional`에 의한 DB 커밋은 그 이후에 발생한다.
>   - **현상**: Thread A가 락을 해제하는 순간, 아직 DB에는 데이터가 반영(Commit)되지 않았다. 이때 대기하던 Thread B가 즉시 락을 잡고 진입하면, B는 여전히 `AVAILABLE` 상태의 데이터를 읽게 된다.
> 
> **함정 2: 스프링 프록시의 한계 (Internal Call)**
>   - **문제**: `createReservationWithDistributedLock` 내부에서 `this.createReservation()`을 호출하면, 스프링의 AOP 프록시가 작동하지 않아 `@Transactional`이 무시된다.
>   - **현상**: 각 DB 작업이 개별 트랜잭션으로 돌거나 커밋 시점이 모호해져서 락의 보호를 전혀 받지 못하게 된다.
> 
> #### 3. 교훈 (Lesson Learned)
> ---
> > **"분산 락의 해제 시점은 반드시 트랜잭션의 커밋 시점보다 늦어야 한다."**
> > 또한, 트랜잭션 전파를 위해 별도의 Facade 클래스를 두거나 스프링 빈의 외부 호출을 이용해야 한다.
> 
> 
> ### Step 3-2: 두 번째 시도 (성공 사례 - Facade 패턴 도입)
> ---
> 
> #### 1. Facade(파사드) 패턴이란?
> ---
> '건물의 정면'이라는 뜻으로, 내부의 복잡한 로직들을 하나의 겉껍데기 클래스로 감싸서 밖에서는 단순하게 보이게 만드는 디자인 패턴이다.
> 
> #### 2. 왜 Facade가 필요한가? (트랜잭션의 함정)
> ---
> 스프링의 `@Transactional`은 메서드가 완전히 끝날 때 DB에 내용을 저장(Commit)한다.
>   - **Service 내부에서 락을 걸면**: 메서드 끝에서 락을 먼저 풀고, 그 **다음에** DB 저장이 일어난다. (그 사이 찰나에 다른 놈이 들어와서 사고 발생!)
>   - **Facade를 사용하면**: 
>   1. Facade에서 락을 잡는다.
>   2. Service의 트랜잭션 메서드를 부른다. (DB 저장까지 완벽히 끝날 때까지 기다림)
>   3. **DB 저장이 확실히 끝난 뒤에** Facade에서 락을 푼다.
> 
> #### 3. 해결 전략: RedissonLockFacade 전체 코드
> ---
> 생략 없이 실제 구현된 코드를 통해 락과 트랜잭션의 조율 과정을 확인한다.
> 
> ```java
> @Component
> @RequiredArgsConstructor
> public class RedissonLockFacade {
> 
>     private final RedissonClient redissonClient;
>     private final ReservationService reservationService;
> 
>     public ReservationResponse createReservation(ReservationRequest request) {
        String lockKey = "lock:seat:" + request.seatId();
        RLock lock = redissonClient.getLock(lockKey);

        try {
            // [중요 설계 변경] 짐작에 의한 숫자(Magic Number) 배제
            // 1. Wait Time: 비즈니스 타임아웃 정책에 따라 설정 (ex: 10초)
            // 2. Lease Time: -1로 설정하여 Redisson Watchdog(감시견)에게 관리를 위임
            boolean available = lock.tryLock(10, -1, TimeUnit.SECONDS);

            if (!available) {
                throw new RuntimeException("락 획득 실패: 서버가 바쁩니다. 잠시 후 다시 시도해주세요.");
            }

            return reservationService.createReservation(request);

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}
```

---


##  [Special] Magic Number를 배제한 자율적 시스템 설계 (중요)
---
> [!NOTE]
> 
> 이 섹션은 단순히 코드를 짜는 것을 넘어, **"진정한 프로그램이란 무엇인가"**에 대한 엔지니어링 철학을 다룬다.
> 
> ### 1. 짐작하는 숫자의 위험성 (Anti-Programming)
> ---
> 초기에 작성했던 `lock.tryLock(10, 2, TimeUnit.SECONDS)` 코드에서 `2초`라는 숫자는 개발자의 **'짐작'**에 불과하다. 
> 
> ####  나쁜 예시 (Bad Practice: Guessing Numbers)
> ---
> ```java
> // 로직이 2초 안에 끝날 것이라고 '짐작'하여 하드코딩
> // 만약 DB가 느려져 2.1초가 걸리면? -> 락이 풀리고 중복 데이터 발생! 정합성 파괴!
> boolean available = lock.tryLock(10, 2, TimeUnit.SECONDS); 
> ```
> 
> ####  좋은 예시 (Best Practice: Autonomous Management)
> ---
> ```java
> // 1. 대기 시간은 정책(Policy)으로 관리
> private static final long MAX_WAIT_TIME = 10L; 
> 
> // 2. 점유 시간은 -1로 설정하여 시스템(Watchdog)이 스스로 판단하게 함
> // 로직이 얼마나 걸리든 안전하게 정합성 유지
> boolean available = lock.tryLock(MAX_WAIT_TIME, -1, TimeUnit.SECONDS);
> ```
> 
> ### 2. 설정 파일(`application.yml`)조차 하드코딩이다
> ---
> 값을 설정 파일로 옮기는 행위는 관리의 편의성을 높일 뿐, 결국 사람이 정한 **'정적 수치'**라는 본질은 변하지 않는다. 진정한 해결책은 시스템이 상황에 맞춰 **'스스로 판단'**하게 만드는 것이다.
> 
> ### 3. 자율적 해결책: Redisson Watchdog (감시견)
> ---
> 우리는 `leaseTime`을 `-1`로 설정함으로써 이 문제를 우아하게 해결했다.
>   - **작동 원리**: 로직이 실행 중인 동안 Redisson이 주기적으로 락의 유효시간을 연장한다. 
>   - **장점**: 로직이 0.1초 만에 끝나든, 10초가 걸리든 **상황에 맞춰 락 유지 시간을 스스로 조절**한다.
>   - **안전성**: 만약 서버가 갑자기 죽어 연장 신호를 못 보내면, 그때서야 락을 해제하여 데드락(Deadlock)을 방지한다.
> 
> ###  핵심 교훈: "상황을 단정 짓지 말고, 시스템이 흐르게 하라"
> ---
> > **"설정값은 최소화하고, 자율적인 메커니즘(Watchdog 등)을 우선시하는 설계가 대규모 분산 시스템에서 살아남는 프로그래밍 방식이다."**
> 
> 
> #### 4. 실험 결과 (성공)
> ---
>   - **성공 횟수**: 1건
>   - **실패 횟수**: 29건
>   - **최종 예약 건수**: 1건 (정합성 완벽 유지)
> 
> #### 3. 핵심 동작 원리
> ---
> 1. **락 획득**: Thread A가 Redis 락 점유.
> 2. **트랜잭션 실행**: 서비스 계층의 트랜잭션 메서드 호출 및 **DB 커밋 완료**.
> 3. **락 해제**: 트랜잭션이 완전히 종료된 후 Facade에서 락 해제.
> 4. **후속 처리**: Thread B가 진입 시, 이미 커밋된 `RESERVED` 상태를 확인하여 중복 예약 방지.
> 
> ### 4. 최종 결론 (Conclusion)
> ---
> 
>   - **비관적 락**은 DB 자원을 많이 소모하지만 설정이 간편하다.
> 
>   - **Redis 분산 락**은 설정이 복잡(Facade 필요)하지만, DB 부하를 획득 시점 이전에 차단할 수 있어 **대규모 트래픽에 훨씬 유리**하다.
> 
> 
> 
> 
> 
> 

##  대장정의 다음 단계: 왜 대기열(Kafka)인가?
---
> [!NOTE]
> 
> 
> 
> 지금까지 우리는 **'데이터 정합성'**을 지키는 법을 배웠다. 하지만 여전히 해결되지 않은 숙제가 남아있다.
> 
> 
> 
> ###  질문: "만 명 중 한 명만 성공한다면, 나머지 9,999명은 어떻게 되는가?"
> ---
> 
분산 락은 정합성을 지켜주지만, 실패한 9,999명에게는 "실패"라는 응답만 돌려준다. 사용자들은 성공할 때까지 계속해서 버튼을 누를 것이고(재시도), 이는 서버에 **'무한 재시도 폭격'**으로 이어진다.



###  해결책: '락(Lock)'에서 '대기열(Queue)'로의 패러다임 전환

- **락(Lock)**: "한 놈만 들어와! 나머지는 다 꺼져!" (배제와 경쟁)

- **대기열(Queue)**: "일단 모두 줄 서세요. 번호표 순서대로 처리해 드릴게요." (포용과 질서)



### ️ Step 4: Kafka 기반 비동기 예약 시스템 도입 (Next Phase)

이제 우리는 요청을 즉시 처리하지 않고 **Kafka**라는 완충 지대에 담을 것이다.

1. **요청 수집**: 만 명의 요청을 0.1초 만에 Kafka에 쌓는다.

2. **번호표 부여**: 사용자에게 실시간으로 대기 순번을 제공한다.

3. **비동기 처리**: 서버가 감당 가능한 속도로 메시지를 꺼내어 예약 로직을 수행한다.



**결과적으로, 서버는 죽지 않고 사용자는 화내지 않는 '진정한 고성능 시스템'으로 진화한다.**




## Step 4: Kafka 기반 비동기 대기열 (Async Queue) 
---
> [!NOTE]
> 
> ### 1. 왜 '대기열' 방식인가? (The Paradigm Shift)
> ---
> 지금까지의 **락(Lock)** 방식은 "한 놈만 들어와, 나머지는 다 실패야"라는 배제적 방식입니다. 이는 만 명의 사용자가 동시에 접속했을 때 9,999명에게 불쾌한 경험을 주며 서버 자원을 고갈시킵니다.
>   - **Before (Blocking)**: 클라이언트가 요청을 보내면 DB 예약이 끝날 때까지 스레드가 대기(Block)함.
>   - **After (Event-Driven)**: 클라이언트 요청을 즉시 Kafka에 담고 응답(Accepted). 실제 처리는 서버가 감당 가능한 속도로 나중에 수행.
> 
> 
> ### 2. 구현 방법 (How to Apply)
> ---
> 
> #### 2.1. 요청 수집 (Producer)
> ---
> 사용자의 요청을 이벤트 객체로 감싸 Kafka로 쏘아 올립니다. 이때 **`seatId`를 메시지 키(Key)**로 사용하는 것이 핵심입니다.
> 
> ```java
> // [KafkaReservationProducer.java]
> public void send(ReservationEvent event) {
>     // seatId를 키로 설정하여 동일 좌석 요청은 무조건 같은 파티션(순서 보장)으로 전송
>     kafkaTemplate.send(topic, String.valueOf(event.getSeatId()), event);
> }
> ```
> 
> #### 2.2. 비동기 처리 (Consumer)
> ---
> Kafka에서 메시지를 하나씩 꺼내어 실제 예약 로직을 수행합니다. 지정된 `lockType`에 따라 앞선 Step 1~2의 로직을 재사용합니다.
> 
> ```java
> // [KafkaReservationConsumer.java]
> @KafkaListener(topics = "ticket-reservation-events", groupId = "ticket-group")
> public void consume(ReservationEvent event) {
>     // 1. 상태를 PROCESSING으로 변경
>     queueService.setStatus(userId, seatId, "PROCESSING");
>     
>     // 2. 실제 예약 서비스 호출 (Pessimistic or Optimistic)
>     reservationService.createReservationWithPessimisticLock(request);
>     
>     // 3. 성공 시 실시간 알림 전송
>     sseManager.send(userId, seatId, "SUCCESS");
> }
> ```
> 
> #### 2.3. 실시간 결과 통보 (SSE)
> ---
> 사용자가 결과를 기다리지 않도록 서버에서 클라이언트로 데이터를 밀어주는 SSE를 적용했습니다.
> 
> ```java
> ```java
> // [SseEmitterManager.java]
> public void send(Long userId, Long seatId, String status) {
>     String key = userId + ":" + seatId;
>     SseEmitter emitter = emitters.get(key);
>     if (emitter != null) {
>         emitter.send(SseEmitter.event().name("RESERVATION_STATUS").data(status));
>         emitter.complete(); // 임무 완수 후 연결 종료
>     }
> }
> ```
> 
> ### 2. 코드 변환 대조 (Sync to Async Migration)
> ---
> 
> 개발자가 기존 동기 API를 비동기 대기열 방식으로 전환할 때 참고할 수 있도록 코드 변화를 대조합니다.
>         emitter.complete(); // 임무 완수 후 연결 종료
>     }
> }
> ```
> 
> ### 2. 코드 변환 대조 (Sync to Async Migration)
> ---
> 
> 개발자가 기존 동기 API를 비동기 대기열 방식으로 전환할 때 참고할 수 있도록 코드 변화를 대조합니다.
> 
> ####  Before: 동기식 요청 처리 (Blocking)
> ---
>   - 클라이언트가 요청을 보내면, DB 작업이 끝날 때까지 서버 스레드가 붙잡혀 있습니다.

---

## Step 5: Redis Sorted Set 기반 실시간 대기열 
---
> [!NOTE]
> **핵심 가치**: 사용자에게 "내 앞의 대기자 수"를 실시간으로 피드백하여 UX를 혁신하고, 서버 인입량을 조절하는 중추적 역할을 수행합니다.
> 
> ### 1. 개요 (Overview)
> ---
>   - 단순히 Kafka에 요청을 쌓는 것만으로는 사용자의 불안감을 해소할 수 없습니다. 
>   - "내 앞에 5,000명이 대기 중입니다"와 같은 구체적인 정보 제공을 통해 사용자 경험(UX)을 혁신하는 것이 목표입니다.
> 
> ### 2. 핵심 매커니즘: Redis Sorted Set (ZSET)
> ---
>   - **Key**: `waiting-queue:concert:{concertId}`
>   - **Score**: `System.currentTimeMillis()` (시간 기반 자동 정렬)
>   - **장점**: 이진 탐색 기반의 알고리즘($O(\log N)$)을 사용하여 수백만 명 중 내 순위를 즉시 조회 가능.
> 
> ### ️ 3. 실제 구현 코드 (WaitingQueueServiceImpl)
> ---
>   ```java
>   @Override
>   public WaitingQueueResponse join(Long userId, Long concertId) {
>       String queueKey = QUEUE_KEY_PREFIX + concertId;
>       String userIdStr = String.valueOf(userId);
>       // 활성 상태 확인
>       if (Boolean.TRUE.equals(redisTemplate.hasKey(ACTIVE_KEY_PREFIX + userIdStr))) {
>           return WaitingQueueResponse.builder().userId(userId).concertId(concertId).status("ACTIVE").rank(0L).build();
>       }
>       // 대기열 진입
>       redisTemplate.opsForZSet().add(queueKey, userIdStr, System.currentTimeMillis());
>       return getStatus(userId, concertId);
>   }
>   ```
> 
> ###  4. 검증 결과 및 효과 (Results & Impact)
> ---
>   - **실제 출력 로그**: `[User 101] WAITING (Rank: 1)`, `[User 102] WAITING (Rank: 2)`
>   - **비포/애프터**: 무한 대기(Step 4) -> 실시간 순번 피드백(Step 5).
>   - **효과**: UX 혁신 및 불필요한 새로고침 재요청 차단으로 서버 부하 급감.

---

## Step 6: 유입량 제어 전략 (Throttling) 
---
> [!WARNING]
> **시스템 생존 보장**: 임계치 이상의 요청을 사전에 차단하고 활성화 인원을 동적으로 조절하는 최종 수비 단계입니다.
> 
> ### 1. 핵심 제어 매커니즘 (Control Mechanisms)
> ---
>   - **1.1. 진입 차단 (Throttling)**: `ZCARD` 명령어로 현재 대기 인원을 체크하여 임계치 초과 시 진입 거부 응답 반환.
>   - **1.2. 유입량 동적 조절**: 서버 상태(CPU, DB 부하)에 따라 활성화 인원수를 가변적으로 운영.
>   - **1.3. ACTIVE 토큰 검증**: 인터셉터를 구현하여 Redis에 `active-user:{id}` 키가 존재하는 사용자만 예약 허용.
> 
> ###  2. 상태 전이도 (State Transition)
> ---
>   - `WAITING (ZSET)` -> `CHECK_THROTTLE` -> `ACTIVE (String + TTL)` -> `RESERVING (API 호출)`
