# 동시성 제어 전략 (Concurrency Control Strategy)

> **Purpose**: 선착순 좌석 예약 시스템에서 발생하는 데이터 정합성 문제 해결 및 성능 최적화 전략 기록
> **Date**: 2026-02-05

## 0. 이론 배경: 낙관적 락 vs 비관적 락 (Theory)

동시성 문제를 해결하는 두 가지 주요 접근 방식의 장단점 비교.

| 특징 | 낙관적 락 (Optimistic Lock) | 비관적 락 (Pessimistic Lock) |
| :--- | :--- | :--- |
| **기본 사상** | "충돌은 드물 거야. 충돌 나면 그때 해결하자." | "충돌은 빈번할 거야. 아예 못 건드리게 막자." |
| **구현 방식** | DB 락을 걸지 않음. 버전 컬럼(`@Version`) 비교. | DB 락(`SELECT ... FOR UPDATE`)을 실제로 검. |
| **성능 (DB)** | **높음** (락 대기 없음) | **낮음** (대기 발생, 데드락 위험) |
| **충돌 처리** | 예외 발생 (`Exception`) -> 롤백 -> 재시도 필요 | 대기 (`Wait`) -> 순차 처리 -> 성공 |
| **적합한 상황** | **읽기가 많고 충돌이 적은 경우** | **쓰기가 많고 충돌이 잦은 경우** |
| **대표 예시** | **게시판 수정, 프로필 업데이트** | **선착순 예매, 재고 차감, 계좌 이체** |
| **비고** | 실패 시 재시도(Retry) 로직 구현 비용 발생 | 트랜잭션 길이에 따라 전체 성능 저하 우려 |

---

## 📋 실험 기록 순서 (Progress)
1. [Step 0: 문제 상황 (락 미적용)](#step-0-문제-상황-락-미적용) - **Completed**
2. [Step 1: 낙관적 락 (Optimistic Lock)](#step-1-낙관적-락-optimistic-lock) - **Completed**
3. [Step 2: 비관적 락 (Pessimistic Lock)](#step-2-비관적-락-pessimistic-lock) - **Completed**
4. [Step 3: Redis 분산 락 (Distributed Lock)](#) - Pending

---

## Step 0: 문제 상황 (락 미적용)

### 1. 실험 환경
- **조건**: `Seat` 엔티티의 `@Version` 어노테이션을 제거하여 낙관적 락을 비활성화.
- **시나리오**: 30명의 유저가 동시에 1개 좌석 예약 시도.

### 2. 실험 결과 (실패)
데이터 정합성이 완전히 깨지는 현상이 발생함. (중복 예약 발생)

#### [수치 결과]
| 항목 | 결과값 | 비고 |
| :--- | :--- | :--- |
| **성공 횟수** | 10건 | **치명적 오류**: 1건이어야 함 |
| **최종 예약 건수** | **10건** | **중복 예약 발생 (Race Condition)** |

---

## Step 1: 낙관적 락 (Optimistic Lock)

### 1. 목적 (Objective)
JPA의 `@Version` 기능을 사용하여 별도의 DB 락 없이 충돌을 감지하고 데이터 정합성을 유지하는지 검증한다.

### 2. 실험 결과 및 로그 분석

#### [수치 결과]
| 항목 | 결과값 |
| :--- | :--- |
| **성공 횟수** | 1건 |
| **실패 횟수** | 29건 (OptimisticLockException) |

#### [실제 SQL 로그 증거]
첫 번째 성공한 스레드 외에는 모두 아래와 같이 `version` 조건이 일치하지 않아 실패함.
```sql
update seats 
set status='RESERVED', version=1 
where id=1 and version=0; -- 현재 버전이 0인 경우에만 성공
```

#### [결론 및 이론적 고찰]
* **"데이터가 꼬이는 걸 막고 싶다"**: 네, `@Version`만 붙이면 됩니다. (가성비 최고, 최소한의 안전장치)
* **"사용자를 화나게 하고 싶지 않다"**: 낙관적 락만으로는 부족합니다. 99명에게 에러 화면을 보여주는 대신, 순차적으로 처리해주는 **비관적 락**이나 **대기열 시스템**이 필요합니다.

---

## Step 2: 비관적 락 (Pessimistic Lock)

### 1. 목적 (Objective)
DB의 `SELECT ... FOR UPDATE`를 사용하여 동시 요청을 **대기(Wait)** 상태로 만들고, 순차적으로 처리하여 데이터 정합성을 강력하게 보장한다.

### 2. 실험 결과 및 로그 분석

#### [수치 결과]
| 항목 | 결과값 |
| :--- | :--- |
| **성공 횟수** | 1건 |
| **실패 횟수** | 29건 (애플리케이션 로직에서 차단) |

#### [실제 SQL 로그 증거]
모든 스레드가 `for update`를 통해 락을 획득하려고 시도하며 줄을 섬.
```sql
select s1_0.id, ... from seats s1_0 where s1_0.id=? for update
```

#### [결론]
* **장점**: 낙관적 락과 달리 **순차 처리**가 보장되어 충돌 예외 발생을 최소화함.
* **단점**: DB 커넥션을 오래 점유하여 대규모 트래픽 시 성능 저하 우려.
* **의사 결정**: 더 높은 처리량을 위해 **Redis 분산 락** 도입 검토 필요.
