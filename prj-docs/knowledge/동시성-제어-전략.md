# 🏯 동시성 제어 전략 (Concurrency Control Strategy)

> **Purpose**: 선착순 좌석 예약 시스템에서 발생하는 데이터 정합성 문제 해결 및 성능 최적화 전략 기록
> **Date**: 2026-02-05

## 0. 이론 배경: 낙관적 락 vs 비관적 락 (Theory)

동시성 문제를 해결하는 두 가지 주요 접근 방식의 장단점 비교.

| 특징 | 낙관적 락 (Optimistic Lock) | 비관적 락 (Pessimistic Lock) |
| :--- | :--- | :--- |
| **기본 사상** | "충돌은 드물 거야. 충돌 나면 그때 해결하자." | "충돌은 빈번할 거야. 아예 못 건드리게 막자." |
| **구현 방식** | DB 락을 걸지 않음. 버전 컬럼(`@Version`) 비교. | DB 락(`SELECT ... FOR UPDATE`)을 실제로 검. |
| **성능 (DB)** | **높음** (락 대기 없음) | **낮음** (대기 발생, 데드락 위험) |
| **충돌 처리** | 예외 발생 (`Exception`) -> 롤백 -> 재시도 필요 | 대기 (`Wait`) -> 순차 처리 -> 성공 |
| **적합한 상황** | **읽기가 많고 충돌이 적은 경우** | **쓰기가 많고 충돌이 잦은 경우** |
| **대표 예시** | **게시판 수정, 프로필 업데이트**<br>(충돌 시 사용자가 다시 수정해도 되는 작업) | **선착순 예매, 재고 차감, 계좌 이체**<br>(데이터 정합성이 매출/신뢰도와 직결되는 작업) |
| **비고** | 실패 시 재시도(Retry) 로직 구현 비용 발생 | 트랜잭션 길이에 따라 전체 성능 저하 우려 |

---

## 📋 실험 기록 순서 (Progress)
1. [Step 0: 문제 상황 (락 미적용)](#step-0-문제-상황-락-미적용) - **Completed**
2. [Step 1: 낙관적 락 (Optimistic Lock)](#step-1-낙관적-락-optimistic-lock) - **Current**
3. [Step 2: 비관적 락 (Pessimistic Lock)](#) - Pending
4. [Step 3: Redis 분산 락 (Distributed Lock)](#) - Pending

---

## Step 0: 문제 상황 (락 미적용)

### 1. 실험 환경
- **조건**: `Seat` 엔티티의 `@Version` 어노테이션을 제거하여 낙관적 락을 비활성화.
- **시나리오**: 30명의 유저가 동시에 1개 좌석 예약 시도.

### 2. 실험 결과 (실패)
데이터 정합성이 완전히 깨지는 현상이 발생함.

#### [수치 결과]
| 항목 | 결과값 | 비고 |
| :--- | :--- | :--- |
| **성공 횟수** | 10건 | **치명적 오류**: 1건이어야 함 |
| **실패 횟수** | 20건 | |
| **최종 예약 건수** | **10건** | **중복 예약 발생 (Race Condition)** |

#### [로그 분석]
여러 스레드가 동시에 `SELECT`로 좌석 상태가 `AVAILABLE`임을 확인하고, 동시에 `INSERT`를 수행하여 중복 데이터가 생성됨.

```text
================ 실험 결과 ================
성공 유저 수: 10
실패 유저 수: 20
DB에 저장된 예약 건수: 10
=========================================
동시성_테스트_1_낙관적_락 > 낙관적 락 동작 확인: 30명 동시 예약 시 1명만 성공 FAILED
    org.opentest4j.AssertionFailedError: 
    expected: 1L
     but was: 10L
```

---

## Step 1: 낙관적 락 (Optimistic Lock)

### 1. 목적 (Objective)
JPA의 `@Version` 기능을 사용하여 별도의 DB 락 없이 충돌을 감지하고 데이터 정합성을 유지하는지 검증한다.

### 2. 실험 시나리오
- **테스트 코드**: `동시성_테스트_1_낙관적_락.java`
- **대상**: 1개 좌석 (Seat ID: 1)
- **부하**: 30명의 스레드가 동시에 예약 API 호출

### 3. 실험 결과 및 로그 분석

#### [수치 결과]
| 항목 | 결과값 |
| :--- | :--- |
| **성공 횟수** | 1건 |
| **실패 횟수** | 29건 |
| **최종 예약 건수** | 1건 (정합성 유지 완료) |

#### [실제 SQL 로그 증거]
첫 번째 성공한 스레드 외에는 모두 아래와 같이 `version` 조건이 일치하지 않아 실패함.

```sql
/* update for com.ticketrush.domain.concert.entity.Seat */
update seats 
set
    status='RESERVED',
    version=1  -- 버전 증가
where
    id=1 
    and version=0; -- 현재 버전이 0인 경우에만 업데이트 성공
```

#### [발생 예외]
나머지 스레드들에서는 JPA 표준 예외인 `ObjectOptimisticLockingFailureException`이 발생하며 트랜잭션이 롤백됨.

### 4. 결론 및 이론적 고찰 (Conclusion & Theory)

#### [낙관적 락의 본질]
낙관적 락(`@Version`)은 엄밀히 말해 **'락(Lock)'**이라기보다는 **'충돌 감지(Conflict Detection)'** 메커니즘입니다. DB에 락을 걸어 대기시키는 것이 아니라, 커밋 시점에 버전이 다르면 예외를 발생시키고 롤백시킵니다.

#### [장단점 요약]
*   **장점 (Pros)**: 별도의 DB 락을 점유하지 않아 데드락(Deadlock) 위험이 없고, 읽기 성능이 매우 뛰어납니다.
*   **단점 (Cons)**: 충돌이 발생하면 애플리케이션 레벨에서 재시도(Retry) 로직을 구현해야 하며, 선착순 이벤트처럼 충돌이 빈번한 경우 대부분의 요청이 실패로 돌아가 리소스 낭비가 심합니다.

#### [핵심 요약]
> * **"데이터가 꼬이는 걸 막고 싶다"**: 네, `@Version`만 붙이면 됩니다. (가성비 최고, 최소한의 안전장치)
> * **"사용자를 화나게 하고 싶지 않다"**: 낙관적 락만으로는 부족합니다. 99명에게 에러 화면을 보여주는 대신, 순차적으로 처리해주는 **비관적 락**이나 **대기열 시스템** 등 더 고도화된 방법이 필요합니다.

---
> **Next Step**: 대기(Wait)를 통해 사용자의 요청을 순차적으로 성공시키는 `SELECT ... FOR UPDATE` (비관적 락) 실험 진행 예정.