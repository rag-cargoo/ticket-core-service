# Redis Sorted Set 기반 실시간 대기열 전략

> **Purpose**: 사용자에게 실시간 대기 순번을 제공하고, 시스템 부하에 따른 유입량을 조절하기 위한 대기열 시스템 설계
> **Date**: 2026-02-06

## 1. 개요 (Overview)

단순히 Kafka에 요청을 쌓는 것(Step 4)만으로는 사용자의 불안감을 해소할 수 없습니다. "내 앞에 5,000명이 대기 중입니다"와 같은 구체적인 정보 제공이 필요합니다.

### 핵심 매커니즘: Redis Sorted Set (ZSET)
- **Key**: `waiting-queue:{concertId}`
- **Member**: `userId`
- **Score**: `System.currentTimeMillis()` (먼저 온 사람이 낮은 점수를 가짐)

---

## 2. 프로세스 플로우 (Process Flow)

### 1단계: 대기열 진입 (Enqueue)
사용자가 예약 버튼을 누르면 즉시 ZSET에 추가됩니다.
- 명령어: `ZADD waiting-queue:1 1707200000000 userA`

### 2단계: 대기 순번 조회 (Polling/SSE)
사용자는 자신의 현재 순위를 조회합니다.
- 명령어: `ZRANK waiting-queue:1 userA` -> 결과: `0` (첫 번째)
- 사용자 응답: "내 앞에 `0`명 대기 중입니다."

### 3단계: 활성 상태 전환 (Activation)
스케줄러나 특정 주기마다 상위 N명을 대기열에서 제거하고 '활성(Active) 상태'로 전환합니다.
- 명령어: 
  1. `ZRANGE waiting-queue:1 0 9` (상위 10명 추출)
  2. `ZREM waiting-queue:1 userA userB ...` (대기열에서 제거)
  3. `SET active-user:userA true EX 300` (5분간 유효한 진입권 부여)

### 4단계: 실제 예약 수행
'활성 상태'인 사용자만 실제 예약 API(`POST /reservations`)를 호출할 수 있습니다.

---

## 3. 상태 정의 (Status Definition)

| 상태 | 설명 | 저장소 |
| :--- | :--- | :--- |
| **WAITING** | 대기열에서 자기 차례를 기다리는 상태 | Redis ZSET |
| **ACTIVE** | 진입 권한을 얻어 실제 예약을 진행할 수 있는 상태 | Redis String (TTL 적용) |
| **COMPLETED** | 예약을 성공적으로 마친 상태 | RDB (Reservation 테이블) |

---

## 4. 기술적 고려사항 (Technical Issues)

### Q1. 얼마나 자주 활성 상태로 전환해야 하는가?
- 서버의 초당 처리량(TPS)에 따라 조절합니다. 
- 예: 서버가 초당 100건을 처리 가능하다면, 1초마다 100명씩 활성화합니다.

### Q2. 사용자가 대기 중에 브라우저를 닫으면?
- `ZREM`을 명시적으로 호출하지 않더라도, 활성 전환 시 '활성 권한(TTL)'이 만료되면 자연스럽게 소멸됩니다.
- 대기열 정합성을 위해 주기적으로 오래된 대기자를 청소하는 로직이 필요할 수 있습니다.
