분산 락은 정합성을 지켜주지만, 실패한 9,999명에게는 "실패"라는 응답만 돌려준다. 사용자들은 성공할 때까지 계속해서 버튼을 누를 것이고(재시도), 이는 서버에 **'무한 재시도 폭격'**으로 이어진다.



### 💡 해결책: '락(Lock)'에서 '대기열(Queue)'로의 패러다임 전환

- **락(Lock)**: "한 놈만 들어와! 나머지는 다 꺼져!" (배제와 경쟁)

- **대기열(Queue)**: "일단 모두 줄 서세요. 번호표 순서대로 처리해 드릴게요." (포용과 질서)



### 🏗️ Step 4: Kafka 기반 비동기 예약 시스템 도입 (Next Phase)

이제 우리는 요청을 즉시 처리하지 않고 **Kafka**라는 완충 지대에 담을 것이다.

1. **요청 수집**: 만 명의 요청을 0.1초 만에 Kafka에 쌓는다.

2. **번호표 부여**: 사용자에게 실시간으로 대기 순번을 제공한다.

3. **비동기 처리**: 서버가 감당 가능한 속도로 메시지를 꺼내어 예약 로직을 수행한다.



**결과적으로, 서버는 죽지 않고 사용자는 화내지 않는 '진정한 고성능 시스템'으로 진화한다.**



## Step 4: Kafka 기반 비동기 대기열 (Async Queue) ✅

### 1. 왜 '대기열' 방식인가? (The Paradigm Shift)
지금까지의 **락(Lock)** 방식은 "한 놈만 들어와, 나머지는 다 실패야"라는 배제적 방식입니다. 이는 만 명의 사용자가 동시에 접속했을 때 9,999명에게 불쾌한 경험을 주며 서버 자원을 고갈시킵니다.
- **Before (Blocking)**: 클라이언트가 요청을 보내면 DB 예약이 끝날 때까지 스레드가 대기(Block)함.
- **After (Event-Driven)**: 클라이언트 요청을 즉시 Kafka에 담고 응답(Accepted). 실제 처리는 서버가 감당 가능한 속도로 나중에 수행.

---

### 2. 구현 방법 (How to Apply)

#### 2.1. 요청 수집 (Producer)
사용자의 요청을 이벤트 객체로 감싸 Kafka로 쏘아 올립니다. 이때 **`seatId`를 메시지 키(Key)**로 사용하는 것이 핵심입니다.

```java
// [KafkaReservationProducer.java]
public void send(ReservationEvent event) {
    // seatId를 키로 설정하여 동일 좌석 요청은 무조건 같은 파티션(순서 보장)으로 전송
    kafkaTemplate.send(topic, String.valueOf(event.getSeatId()), event);
}
```

#### 2.2. 비동기 처리 (Consumer)
Kafka에서 메시지를 하나씩 꺼내어 실제 예약 로직을 수행합니다. 지정된 `lockType`에 따라 앞선 Step 1~2의 로직을 재사용합니다.

```java
// [KafkaReservationConsumer.java]
@KafkaListener(topics = "ticket-reservation-events", groupId = "ticket-group")
public void consume(ReservationEvent event) {
    // 1. 상태를 PROCESSING으로 변경
    queueService.setStatus(userId, seatId, "PROCESSING");
    
    // 2. 실제 예약 서비스 호출 (Pessimistic or Optimistic)
    reservationService.createReservationWithPessimisticLock(request);
    
    // 3. 성공 시 실시간 알림 전송
    sseManager.send(userId, seatId, "SUCCESS");
}
```

#### 2.3. 실시간 결과 통보 (SSE)
사용자가 결과를 기다리지 않도록 서버에서 클라이언트로 데이터를 밀어주는 SSE를 적용했습니다.

```java
// [SseEmitterManager.java]
public void send(Long userId, Long seatId, String status) {
    String key = userId + ":" + seatId;
    SseEmitter emitter = emitters.get(key);
    if (emitter != null) {
        emitter.send(SseEmitter.event().name("RESERVATION_STATUS").data(status));
        emitter.complete(); // 임무 완수 후 연결 종료
    }
}
```

### 2. 코드 변환 대조 (Sync to Async Migration)

개발자가 기존 동기 API를 비동기 대기열 방식으로 전환할 때 참고할 수 있도록 코드 변화를 대조합니다.

#### ❌ Before: 동기식 요청 처리 (Blocking)
클라이언트가 요청을 보내면, DB 작업이 끝날 때까지 서버 스레드가 붙잡혀 있습니다.
```java
// [Controller]
@PostMapping("/v1/optimistic")
public ResponseEntity<ReservationResponse> createReservation(@RequestBody ReservationRequest request) {
    // 즉시 서비스 호출 -> DB 작업 완료까지 대기(Block)
    return ResponseEntity.ok(reservationService.createReservation(request));
}
```

#### ✅ After: 비동기 이벤트 기반 처리 (Non-blocking)
요청을 받자마자 Kafka에 적재하고 즉시 응답합니다. 실제 처리는 별도 컨슈머 스레드에서 수행됩니다.
